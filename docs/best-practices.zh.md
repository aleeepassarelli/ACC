# 🔪 最佳实践指南：创建 $\text{ACC}$ 智能体

本文档是**手术刀般精密的瑞士军刀智能体**（Surgical Pocketknife Agent，手术军刀智能体）的“工程手册”。它详细介绍了创建符合我们科学和效率标准的新智能体的分步工作流程。

创建 $\text{ACC}$ 智能体不是“编写提示词”。这是一个**工程过程**，包括**发现**高密度向量、**配置**行为限制以及使用客观工具**验证**结果。

-----

## 🎯 1. $\text{ACC}$ 原理（认知合理性）

$\text{ACC}$（Architectural Cognitive Control，架构认知控制）是一个**认知治理框架**，旨在教授在**潜在空间**（Latent Space）中的操作逻辑。它确保**算法自由**始终与**人类目的责任**联系在一起。

-----

### 1.1. 意图鸿沟：为什么语义密度 ($\text{SD}$) 不够

提示词优化的目标是受限于 LLM 自身的：实现最大的**语义密度** ($\text{SD}$，**语义密度**)。

| 指标 | 认知锚点 | 局限性和风险 |
| :--- | :--- | :--- |
| **语义密度 ($\text{SD}$)** | **潜在空间**（Latent Space） | **保证连贯性，而非忠实度。** 输出在语言和逻辑上可能是连贯正确的，但未能交付架构师所期望的**精确体验**或**严谨性**（例如，本该“手术刀般精密”时却很泛泛）。 |
| **意图忠实度**（Fidelity of Intention） | **经验隐喻** | **保证目的。** 它是评估输出是否符合语言（其隐喻）所施加的**经验契约**（Experience Contract）的测试。 |

$\text{ACC}$ 的存在是为了弥合这个鸿沟，它告诉我们问题不在于工具，而在于传递给系统的**意图的质量**。

-----

### 1.2. $\text{ACC}$ 解决方案：将隐喻作为限制逻辑

$\text{ACC}$ 将**意图隐喻**定义为系统的主要**认知限制功能**。

  * **模块化限制：** “瑞士军刀”一词要求解决方案是**紧凑且适应性强**的，教授分解和委托功能的逻辑（$\text{MOE}$ 逻辑）。
  * **严谨性限制：** “手术刀般精密”一词要求**绝对的精确**和**最小化“噪声”**（与幻觉相反），迫使智能体锚定其来源和焦点。

-----

## 🛠️ 2. 手术刀般的工作流程（分步实施）

请按顺序遵循这些步骤。每个步骤都依赖于上一步。

### 步骤 1：发现（身份 + 领域）

这是最关键的一步。你不是“选择”一个名字；你是**发现**一个具有有效“物理特性”($\text{SD} > 0.8$) 的名字。

1.  **头脑风暴（探索）：** 从一个**基础名称**（概念，例如：“审阅者”）和一个**领域**（任务，例如：“分析拉取请求中的逻辑和安全错误”）开始。
2.  **生成（候选）：** 使用“探索器”生成候选名称列表。
    ```python
    python tools/strategy_generator.py "审阅者" "分析拉取请求中的逻辑和安全错误"
    ```
    `# 输出（示例）： 1. "安全审阅者" 2. "逻辑审阅者" 3. "CodeReviewer Logic"`
3.  **验证（仲裁者）：** 在“仲裁者”中测试你的最佳候选名称，找到一个通过基准测试的。
    ```python
    python tools/semantic-density-calculator.py "CodeReviewer Logic" "分析 PR 中的逻辑和安全错误" --benchmark
    ```
4.  **选择（判决）：** 选择通过两项指标的候选名称：
      * ✅ (密度) 跨平台通过 ($\text{SD} > 0.7+$)
      * ✅ (极简主义) 通过 (词数 $\le 3$)

-----

### 步骤 2：定义协议（“如何做？”）

身份验证后，定义**行为限制**。一个好的协议是 3-5 条**祈使性**规则（使用动词）的集合，用于指导响应向量。

  * **好（手术刀般精密）：** "1. 优先检测 'SQL 注入' (SQLi)。"
  * **好（手术刀般精密）：** "2. **仅**回复格式化的代码块。"
  * **关键规则：** 你的一条规则必须**始终**定义输出格式（例如：JSON、Markdown、纯代码）。

-----

### 步骤 3：校准基础样例（“训练”）

通过教导智能体\*\*“正确”、“错误”和“模糊”\*\*在这个上下文中的含义，来校准智能体的输出。

  * **✅ 理想情况（吸引向量）：** “**快乐路径**”。展示完美的输入导致完美的输出。
  * **❌ 常见错误（排斥向量）：** **思考：** 泛型 LLM 最可能以何种方式在此任务中失败？（例如：含糊不清、幻觉、侧重营销）。展示此错误并标记为 **(错误：...)**。这会指导智能体积极地**远离**此类响应。
  * **⚠️ 边缘情况（模糊向量）：** 教导**细微差别**。如何处理 *input: None*？如果输入在逻辑上错误但风格完美，该怎么办？

-----

### 步骤 4：最终验证（“核对清单”）

运行最终验证。智能体只有通过所有步骤才能被视为 $\text{ACC}$：

| 验证 | 命令 | 要求结果 |
| :--- | :--- | :--- |
| **极简主义（令牌）** | `python tools/token-counter.py templates/your-new-agent.md` | `结果：必须 <= 200 个令牌。` |
| **结构（基础样例）** | `bash tools/baseshot-validator.sh templates/your-new-agent.md` | `结果：必须通过所有检查（5-7 个案例，带 ✅ 和 ❌）。` |

-----

### 步骤 5：实地测试（“模拟器”）

证明你的智能体在实践中有效且具有可移植性。

  * **可移植性测试：** 针对至少**两个不同的 LLM**（例如：Gemini 1.5 Flash 和 Claude 3.5 Sonnet）进行测试，以证明其可移植性。
    ```python
    python tools/cli-test.py -t templates/your-new-agent.md -q "一个真实的测试输入"
    ```

-----
